from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import cm
from reportlab.pdfgen import canvas
import io
from datetime import datetime
from typing import Dict, List, Any
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import numpy as np

class PDFReportGenerator:
    def __init__(self):
        self.page_width, self.page_height = A4
        self.frontpage_template = '/var/www/assessment_ai/frontpage.png'
        self.report_template = '/var/www/assessment_ai/report.png'
        self.ai_template = '/var/www/assessment_ai/aiconclusion.png'
        self.margin_left = 2.5*cm
        self.margin_right = 2*cm
        self.margin_top = 4*cm
        self.margin_bottom = 2*cm
        self.content_width = self.page_width - self.margin_left - self.margin_right

    def generate_assessment_report(self, session_data: Dict, results_data: List[Dict], 
                                 stats_data: Dict, ai_conclusions: str = None) -> bytes:
        buffer = io.BytesIO()
        c = canvas.Canvas(buffer, pagesize=A4)
        
        # Pagina 1: Copertina
        self._draw_frontpage(c, session_data)
        c.showPage()
        
        # Pagina 2: Radar Processi vs Domini (7 linee su 4 assi)
        self._draw_report_page(c)
        self._add_radar_processes_vs_domains(c, stats_data)
        c.showPage()
        
        
        # Pagina 3: Radar per Processo (7 radar)
        self._draw_report_page(c)
        self._add_process_radars(c, stats_data)
        c.showPage()
        
        # Pagina 4: Radar Domini vs Processi (4 linee su 7 assi)
        self._draw_report_page(c)
        self._add_radar_domains_vs_processes(c, stats_data)
        c.showPage()
        
        # Pagina 5: Radar per Categoria (4 radar)
        self._draw_report_page(c)
        self._add_category_radars(c, stats_data)
        c.showPage()
        
        # Pagina 6: Strengths & Weaknesses
        self._draw_report_page(c)
        self._add_strengths_weaknesses(c, stats_data, results_data)
        c.showPage()
        
        # Pagina 7+: Conclusioni AI
        if ai_conclusions:
            self._add_ai_pages(c, ai_conclusions)
        
        c.save()
        buffer.seek(0)
        return buffer.getvalue()

    def _draw_frontpage(self, c: canvas.Canvas, session_data: Dict):
        c.drawImage(self.frontpage_template, 0, 0, width=self.page_width, height=self.page_height, preserveAspectRatio=True, mask='auto')
        company_name = session_data.get('azienda_nome', 'Azienda')
        c.setFont('Helvetica-Bold', 36)
        c.setFillColor(colors.HexColor('#3DBFBF'))
        text_width = c.stringWidth(company_name, 'Helvetica-Bold', 36)
        c.drawString((self.page_width - text_width) / 2, self.page_height * 0.35, company_name)
        date_str = datetime.now().strftime('%d/%m/%Y')
        c.setFont('Helvetica', 14)
        text_width = c.stringWidth(date_str, 'Helvetica', 14)
        c.drawString((self.page_width - text_width) / 2, self.page_height * 0.22, date_str)

    def _draw_report_page(self, c: canvas.Canvas):
        c.drawImage(self.report_template, 0, 0, width=self.page_width, height=self.page_height, preserveAspectRatio=True, mask='auto')

    def _add_radar_processes_vs_domains(self, c: canvas.Canvas, stats_data: Dict):
        """Radar con 4 assi (Domini) e 7 linee (Processi) - Governance in alto"""
        y_pos = self.page_height - self.margin_top - 1*cm
        c.setFont('Helvetica-Bold', 16)
        c.setFillColor(colors.HexColor('#2C3E50'))
        c.drawString(self.margin_left, y_pos, "Global Radar - Processi vs Domini")
        
        processes_radar = stats_data.get('processes_radar', [])
        if not processes_radar:
            return
        
        # Ordina per overall_score
        def calc_area(x):
            d = x.get('dimensions', {})
            vals = [d.get('governance', 0), d.get('monitoring_control', 0), d.get('technology', 0), d.get('organization', 0)]
            avg_r = sum(vals) / len(vals)
            return (len(vals) * (avg_r ** 2) * np.sin(2 * np.pi / len(vals))) / 2
        processes_radar = sorted(processes_radar, key=calc_area, reverse=True)
        
        fig, ax = plt.subplots(figsize=(7, 7), subplot_kw=dict(projection='polar'))
        
        dimensions = ['Governance', 'M&C', 'Technology', 'Organization']
        num_dims = len(dimensions)
        angles = np.linspace(0, 2 * np.pi, num_dims, endpoint=False).tolist()
        # Rotazione gestita con set_theta_offset
        angles += angles[:1]
        
        colors_list = ['#8B5CF6', '#3B82F6', '#F59E0B', '#10B981', '#EF4444', '#EC4899', '#06B6D4']
        
        for i, proc in enumerate(processes_radar):
            dims = proc.get('dimensions', {})
            values = [
                dims.get('governance', 0),
                dims.get('monitoring_control', 0),
                dims.get('technology', 0),
                dims.get('organization', 0)
            ]
            values += values[:1]
            color = colors_list[i % len(colors_list)]
            values_list = [dims.get('governance', 0), dims.get('monitoring_control', 0), dims.get('technology', 0), dims.get('organization', 0)]
            n = len(values_list)
            avg_radius = sum(values_list) / n
            area = (n * (avg_radius ** 2) * np.sin(2 * np.pi / n)) / 2
            label = f"{proc.get('process', '')} ({area:.2f})"
            ax.plot(angles, values, 'o-', linewidth=2, color=color, label=label, markersize=4)
            ax.fill(angles, values, alpha=0.1, color=color)
        
        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(dimensions, size=11, weight='bold')
        ax.set_ylim(0, 5)
        ax.set_yticks([1, 2, 3, 4, 5])
        ax.grid(True, alpha=0.3)
        ax.legend(loc='upper right', bbox_to_anchor=(1.3, 1.1), fontsize=8)
        ax.set_theta_offset(np.pi/2)  # Governance in alto
        ax.set_aspect('equal')
        
        img_buffer = io.BytesIO()
        plt.savefig(img_buffer, format='png', dpi=100, bbox_inches='tight')
        plt.close()
        img_buffer.seek(0)
        
        from reportlab.lib.utils import ImageReader
        img = ImageReader(img_buffer)
        c.drawImage(img, self.margin_left - 1*cm, y_pos - 16*cm, width=18*cm, height=15*cm, preserveAspectRatio=True)

    def _add_radar_domains_vs_processes(self, c: canvas.Canvas, stats_data: Dict):
        """Radar con 7 assi (Processi) e 4 linee (Domini) - MKTG in alto"""
        y_pos = self.page_height - self.margin_top - 1*cm
        c.setFont('Helvetica-Bold', 16)
        c.setFillColor(colors.HexColor('#2C3E50'))
        c.drawString(self.margin_left, y_pos, "Global Radar - Domini vs Processi")
        
        processes_radar = stats_data.get('processes_radar', [])
        if not processes_radar:
            return
        
        # Ordina per overall_score per avere MKTG in posizione corretta
        # Ma per il radar, l'ordine deve essere quello della pagina: MKTG in alto
        # Ordiniamo alfabeticamente o per come appare online
        process_order = ['MKTG', 'DESIGN & ENGINEERING', 'EXECUTION', 'QUALITY MANAGEMENT', 'CUSTOMER CARE', 'DIGITAL MKTG', 'ADMINISTRATION']
        
        # Riordina secondo l'ordine specificato
        ordered_processes = []
        for pname in process_order:
            for p in processes_radar:
                if p.get('process', '').upper() == pname.upper():
                    ordered_processes.append(p)
                    break
        
        # Aggiungi eventuali processi mancanti
        for p in processes_radar:
            if p not in ordered_processes:
                ordered_processes.append(p)
        
        if not ordered_processes:
            ordered_processes = processes_radar
        
        fig, ax = plt.subplots(figsize=(7, 7), subplot_kw=dict(projection='polar'))
        
        process_names = [p.get('process', '')[:20] for p in ordered_processes]
        num_procs = len(process_names)
        angles = np.linspace(0, 2 * np.pi, num_procs, endpoint=False).tolist()
        # Rotazione gestita con set_theta_offset
        angles_plot = angles + [angles[0]]
        
        # 4 linee per i 4 domini
        domain_data = {
            'Governance': {'color': '#3B82F6', 'values': []},
            'Monitoring & Control': {'color': '#10B981', 'values': []},
            'Technology': {'color': '#F59E0B', 'values': []},
            'Organization': {'color': '#EF4444', 'values': []}
        }
        
        for proc in ordered_processes:
            dims = proc.get('dimensions', {})
            domain_data['Governance']['values'].append(dims.get('governance', 0))
            domain_data['Monitoring & Control']['values'].append(dims.get('monitoring_control', 0))
            domain_data['Technology']['values'].append(dims.get('technology', 0))
            domain_data['Organization']['values'].append(dims.get('organization', 0))
        
        for domain_name, data in domain_data.items():
            values = data['values'] + [data['values'][0]]
            total = sum(data['values'])
            ax.plot(angles_plot, values, 'o-', linewidth=2, color=data['color'], 
                   label=f"{domain_name} ({total:.2f})", markersize=4)
            ax.fill(angles_plot, values, alpha=0.1, color=data['color'])
        
        ax.set_xticks(angles)
        ax.set_xticklabels(process_names, size=8, weight='bold')
        ax.set_ylim(0, 5)
        ax.set_yticks([1, 2, 3, 4, 5])
        ax.grid(True, alpha=0.3)
        ax.legend(loc='upper right', bbox_to_anchor=(1.35, 1.1), fontsize=8)
        ax.set_theta_offset(np.pi/2)  # MKTG in alto
        ax.set_aspect('equal')
        
        img_buffer = io.BytesIO()
        plt.savefig(img_buffer, format='png', dpi=100, bbox_inches='tight')
        plt.close()
        img_buffer.seek(0)
        
        from reportlab.lib.utils import ImageReader
        img = ImageReader(img_buffer)
        c.drawImage(img, self.margin_left - 1*cm, y_pos - 16*cm, width=18*cm, height=15*cm, preserveAspectRatio=True)

    def _add_category_radars(self, c: canvas.Canvas, stats_data: Dict):
        """4 radar (uno per categoria) con 7 assi (processi)"""
        y_pos = self.page_height - self.margin_top - 1*cm
        c.setFont('Helvetica-Bold', 16)
        c.setFillColor(colors.HexColor('#2C3E50'))
        c.drawString(self.margin_left, y_pos, "Radar per Categoria")
        
        processes_radar = stats_data.get('processes_radar', [])
        if not processes_radar:
            return
        
        processes_radar = sorted(processes_radar, key=lambda x: x.get('overall_score', 0), reverse=True)
        
        categories = [
            ('Governance', 'governance'),
            ('Monitoring & Control', 'monitoring_control'),
            ('Technology', 'technology'),
            ('Organization', 'organization')
        ]
        
        positions = [
            (self.margin_left, self.page_height - 5.5*cm),
            (self.margin_left + 9*cm, self.page_height - 5.5*cm),
            (self.margin_left, self.page_height - 14.5*cm),
            (self.margin_left + 9*cm, self.page_height - 14.5*cm)
        ]
        
        for idx, (cat_name, cat_key) in enumerate(categories):
            x_pos, y_pos = positions[idx]
            
            fig, ax = plt.subplots(figsize=(3.2, 3.2), subplot_kw=dict(projection='polar'))
            
            process_names = [p.get('process', '')[:12] for p in processes_radar]
            values = [p.get('dimensions', {}).get(cat_key, 0) for p in processes_radar]
            
            num_procs = len(process_names)
            angles = np.linspace(0, 2 * np.pi, num_procs, endpoint=False).tolist()
            # Rotazione gestita con set_theta_offset
            values_plot = values + [values[0]]
            angles_plot = angles + [angles[0]]
            
            ax.plot(angles_plot, values_plot, 'o-', linewidth=2, color='#3DBFBF', markersize=4)
            ax.fill(angles_plot, values_plot, alpha=0.3, color='#3DBFBF')
            
            ax.set_xticks(angles)
            ax.set_xticklabels(process_names, size=5)
            ax.set_ylim(0, 5)
            ax.set_yticks([1, 2, 3, 4, 5])
            ax.set_yticklabels(['1', '2', '3', '4', '5'], size=5)
            ax.grid(True, alpha=0.3)
            ax.set_theta_offset(np.pi/2)  # Primo processo in alto
            ax.set_aspect('equal')
            plt.title(cat_name, size=9, weight='bold', y=1.08)
            
            img_buffer = io.BytesIO()
            plt.savefig(img_buffer, format='png', dpi=90, bbox_inches='tight')
            plt.close()
            img_buffer.seek(0)
            
            from reportlab.lib.utils import ImageReader
            img = ImageReader(img_buffer)
            c.drawImage(img, x_pos, y_pos - 8*cm, width=8*cm, height=8*cm, preserveAspectRatio=True)

    def _add_process_radars(self, c: canvas.Canvas, stats_data: Dict):
        """7 radar (uno per processo) con 4 assi (domini)"""
        y_pos = self.page_height - self.margin_top - 1*cm
        c.setFont('Helvetica-Bold', 16)
        c.setFillColor(colors.HexColor('#2C3E50'))
        c.drawString(self.margin_left, y_pos, "Radar per Processo")
        
        processes_radar = stats_data.get('processes_radar', [])
        if not processes_radar:
            return
        
        processes_radar = sorted(processes_radar, key=lambda x: x.get('overall_score', 0), reverse=True)
        
        radar_w = 5*cm
        radar_h = 5*cm
        cols = 3
        x_start = self.margin_left
        y_start = self.page_height - self.margin_top - 3*cm
        
        for idx, proc in enumerate(processes_radar[:9]):
            col = idx % cols
            row = idx // cols
            x_pos = x_start + col * (radar_w + 0.8*cm)
            y_pos = y_start - row * (radar_h + 1.8*cm)
            
            dims = proc.get('dimensions', {})
            process_name = proc.get('process', '')[:18]
            overall = proc.get('overall_score', 0)
            
            fig, ax = plt.subplots(figsize=(2.2, 2.2), subplot_kw=dict(projection='polar'))
            
            dimensions = ['Gov', 'M&C', 'Tech', 'Org']
            values = [
                dims.get('governance', 0),
                dims.get('monitoring_control', 0),
                dims.get('technology', 0),
                dims.get('organization', 0)
            ]
            
            num_dims = len(dimensions)
            angles = np.linspace(0, 2 * np.pi, num_dims, endpoint=False).tolist()
            # Rotazione gestita con set_theta_offset
            values += values[:1]
            angles += angles[:1]
            
            ax.plot(angles, values, 'o-', linewidth=1.5, color='#3B82F6', markersize=3)
            ax.fill(angles, values, alpha=0.3, color='#3B82F6')
            
            ax.set_xticks(angles[:-1])
            ax.set_xticklabels(dimensions, size=6)
            ax.set_ylim(0, 5)
            ax.set_yticks([1, 2, 3, 4, 5])
            ax.set_yticklabels(['', '', '', '', ''], size=5)
            ax.grid(True, alpha=0.3)
            ax.set_theta_offset(np.pi/2)  # Governance in alto
            ax.set_aspect('equal')
            plt.title(f'{process_name}\n({overall:.2f})', size=7, weight='bold', y=1.08)
            
            img_buffer = io.BytesIO()
            plt.savefig(img_buffer, format='png', dpi=80, bbox_inches='tight')
            plt.close()
            img_buffer.seek(0)
            
            from reportlab.lib.utils import ImageReader
            img = ImageReader(img_buffer)
            c.drawImage(img, x_pos, y_pos - radar_h, width=radar_w, height=radar_h, preserveAspectRatio=True)

    def _add_strengths_weaknesses(self, c: canvas.Canvas, stats_data: Dict, results_data: List[Dict]):
        """Tabella Strengths & Weaknesses"""
        y_pos = self.page_height - self.margin_top - 1*cm
        c.setFont('Helvetica-Bold', 14)
        c.setFillColor(colors.HexColor('#2C3E50'))
        c.drawString(self.margin_left, y_pos, "STRENGTHS & WEAKNESSES BY PROCESS")
        y_pos -= 1*cm
        
        processes_radar = stats_data.get('processes_radar', [])
        if not processes_radar:
            return
        
        processes_radar = sorted(processes_radar, key=lambda x: x.get('overall_score', 0), reverse=True)
        
        # Header
        c.setFont('Helvetica-Bold', 8)
        c.setFillColor(colors.HexColor('#3DBFBF'))
        c.rect(self.margin_left, y_pos - 0.5*cm, self.content_width, 0.6*cm, fill=1)
        
        c.setFillColor(colors.white)
        col_x = [self.margin_left + 0.2*cm, self.margin_left + 5.5*cm, self.margin_left + 8*cm,
                 self.margin_left + 10.5*cm, self.margin_left + 13*cm, self.margin_left + 15.5*cm]
        headers = ['Process', 'Governance', 'M&C', 'Technology', 'Org', 'Rating']
        for i, header in enumerate(headers):
            c.drawString(col_x[i], y_pos - 0.3*cm, header)
        
        y_pos -= 0.9*cm
        c.setFont('Helvetica', 7)
        
        for idx, proc in enumerate(processes_radar):
            if y_pos < 3*cm:
                break
            
            if idx % 2 == 0:
                c.setFillColor(colors.HexColor('#F8F9FA'))
                c.rect(self.margin_left, y_pos - 0.35*cm, self.content_width, 0.55*cm, fill=1)
            
            process_name = proc.get('process', '')
            dims = proc.get('dimensions', {})
            overall = proc.get('overall_score', 0)
            
            c.setFillColor(colors.HexColor('#333333'))
            c.drawString(col_x[0], y_pos - 0.2*cm, process_name[:22])
            
            dim_values = [dims.get('governance', 0), dims.get('monitoring_control', 0),
                         dims.get('technology', 0), dims.get('organization', 0)]
            
            for i, val in enumerate(dim_values):
                if val >= 3.0:
                    c.setFillColor(colors.HexColor('#10B981'))
                elif val >= 2.0:
                    c.setFillColor(colors.HexColor('#F59E0B'))
                else:
                    c.setFillColor(colors.HexColor('#EF4444'))
                c.drawString(col_x[i+1], y_pos - 0.2*cm, f"{val:.2f}")
            
            if overall >= 3.0:
                c.setFillColor(colors.HexColor('#10B981'))
            else:
                c.setFillColor(colors.HexColor('#EF4444'))
            c.drawString(col_x[5], y_pos - 0.2*cm, f"{overall:.2f}")
            
            y_pos -= 0.55*cm
    def _add_ai_pages(self, c: canvas.Canvas, ai_conclusions: str):
        """Pagine conclusioni AI"""
        self._draw_ai_page(c)
        y_pos = self.page_height - self.margin_top - 3*cm  # Più in basso per evitare sovrapposizioni
        
        c.setFont('Helvetica-Bold', 16)
        c.setFillColor(colors.HexColor('#2C3E50'))
        c.drawString(self.margin_left, y_pos, "CONCLUSIONI E RACCOMANDAZIONI AI")
        y_pos -= 1*cm
        
        lines = ai_conclusions.split('\n')
        line_height = 10
        
        for line in lines:
            if y_pos < self.margin_bottom + 2*cm:
                c.showPage()
                self._draw_ai_page(c)
                y_pos = self.page_height - self.margin_top - 3*cm
            
            line = line.strip()
            if not line:
                y_pos -= line_height * 0.5
                continue
            
            if line.startswith('###'):
                c.setFont('Helvetica-Bold', 11)
                c.setFillColor(colors.HexColor('#2C3E50'))
                line = line.replace('###', '').strip()
                y_pos -= 0.2*cm
            elif line.startswith('##'):
                c.setFont('Helvetica-Bold', 12)
                c.setFillColor(colors.HexColor('#2C3E50'))
                line = line.replace('##', '').strip()
                y_pos -= 0.3*cm
            elif line.startswith('#'):
                c.setFont('Helvetica-Bold', 13)
                c.setFillColor(colors.HexColor('#2C3E50'))
                line = line.replace('#', '').strip()
                y_pos -= 0.4*cm
            elif line.startswith('-'):
                c.setFont('Helvetica', 8)
                c.setFillColor(colors.HexColor('#333333'))
                line = '• ' + line[1:].strip()
            else:
                c.setFont('Helvetica', 8)
                c.setFillColor(colors.HexColor('#333333'))
            
            words = line.split()
            current_line = ""
            for word in words:
                test_line = current_line + " " + word if current_line else word
                if c.stringWidth(test_line, c._fontname, c._fontsize) < self.content_width:
                    current_line = test_line
                else:
                    if current_line:
                        c.drawString(self.margin_left, y_pos, current_line)
                        y_pos -= line_height
                        if y_pos < self.margin_bottom + 2*cm:
                            c.showPage()
                            self._draw_ai_page(c)
                            y_pos = self.page_height - self.margin_top - 3*cm
                    current_line = word
            if current_line:
                c.drawString(self.margin_left, y_pos, current_line)
                y_pos -= line_height
        
        c.showPage()

    def _draw_ai_page(self, c: canvas.Canvas):
        c.drawImage(self.ai_template, 0, 0, width=self.page_width, height=self.page_height, preserveAspectRatio=True, mask='auto')
