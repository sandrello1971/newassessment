from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import cm
from reportlab.pdfgen import canvas
import io
from datetime import datetime
from typing import Dict, List, Any
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import numpy as np

class PDFReportGenerator:
    def __init__(self):
        self.page_width, self.page_height = A4
        self.frontpage_template = '/var/www/assessment_ai/frontpage.png'
        self.report_template = '/var/www/assessment_ai/report.png'
        self.ai_template = '/var/www/assessment_ai/aiconclusion.png'
        self.margin_left = 2.5*cm
        self.margin_right = 2*cm
        self.margin_top = 4*cm
        self.margin_bottom = 2*cm
        self.content_width = self.page_width - self.margin_left - self.margin_right

    def generate_assessment_report(self, session_data: Dict, results_data: List[Dict], 
                                 stats_data: Dict, ai_conclusions: str = None) -> bytes:
        buffer = io.BytesIO()
        c = canvas.Canvas(buffer, pagesize=A4)
        
        # Pagina 1: Copertina
        self._draw_frontpage(c, session_data)
        c.showPage()
        
        # Pagina 2: Radar Processi vs Domini (7 linee su 4 assi)
        self._draw_report_page(c)
        self._add_radar_processes_vs_domains(c, stats_data)
        c.showPage()
        
        
        # Pagina 3: Radar per Processo (7 radar)
        self._draw_report_page(c)
        self._add_process_radars(c, stats_data)
        c.showPage()
        
        # Pagina 4: Radar Domini vs Processi (4 linee su 7 assi)
        self._draw_report_page(c)
        self._add_radar_domains_vs_processes(c, stats_data)
        c.showPage()
        
        # Pagina 5: Radar per Categoria (4 radar)
        self._draw_report_page(c)
        self._add_category_radars(c, stats_data)
        c.showPage()
        
        # Pagina 6: Strengths & Weaknesses
        self._draw_report_page(c)
        self._add_strengths_weaknesses(c, stats_data, results_data)
        c.showPage()
        
        # Pagina 7+: Conclusioni AI
        if ai_conclusions:
            self._add_ai_pages(c, ai_conclusions)
        
        c.save()
        buffer.seek(0)
        return buffer.getvalue()

    def _draw_frontpage(self, c: canvas.Canvas, session_data: Dict):
        c.drawImage(self.frontpage_template, 0, 0, width=self.page_width, height=self.page_height, preserveAspectRatio=True, mask='auto')
        company_name = session_data.get('azienda_nome', 'Azienda')
        c.setFont('Helvetica-Bold', 36)
        c.setFillColor(colors.HexColor('#3DBFBF'))
        text_width = c.stringWidth(company_name, 'Helvetica-Bold', 36)
        c.drawString((self.page_width - text_width) / 2, self.page_height * 0.35, company_name)
        date_str = datetime.now().strftime('%d/%m/%Y')
        c.setFont('Helvetica', 14)
        text_width = c.stringWidth(date_str, 'Helvetica', 14)
        c.drawString((self.page_width - text_width) / 2, self.page_height * 0.22, date_str)

    def _draw_report_page(self, c: canvas.Canvas):
        c.drawImage(self.report_template, 0, 0, width=self.page_width, height=self.page_height, preserveAspectRatio=True, mask='auto')

    def _add_radar_processes_vs_domains(self, c: canvas.Canvas, stats_data: Dict):
        """Radar con 4 assi (Domini) e 7 linee (Processi) - Governance in alto"""
        y_pos = self.page_height - self.margin_top - 1*cm
        c.setFont('Helvetica-Bold', 16)
        c.setFillColor(colors.HexColor('#2C3E50'))
        c.drawString(self.margin_left, y_pos, "Global Radar - Processi vs Domini")
        
        processes_radar = stats_data.get('processes_radar', [])
        if not processes_radar:
            return
        
        # Ordina per overall_score
        def calc_area(x):
            d = x.get('dimensions', {})
            vals = [d.get('governance', 0), d.get('monitoring_control', 0), d.get('technology', 0), d.get('organization', 0)]
            avg_r = sum(vals) / len(vals)
            return (len(vals) * (avg_r ** 2) * np.sin(2 * np.pi / len(vals))) / 2
        processes_radar = sorted(processes_radar, key=calc_area, reverse=True)
        
        fig, ax = plt.subplots(figsize=(7, 7), subplot_kw=dict(projection='polar'))
        
        dimensions = ['Governance', 'M&C', 'Technology', 'Organization']
        num_dims = len(dimensions)
        angles = np.linspace(0, 2 * np.pi, num_dims, endpoint=False).tolist()
        # Rotazione gestita con set_theta_offset
        angles += angles[:1]
        
        colors_list = ['#8B5CF6', '#3B82F6', '#F59E0B', '#10B981', '#EF4444', '#EC4899', '#06B6D4']
        
        for i, proc in enumerate(processes_radar):
            dims = proc.get('dimensions', {})
            values = [
                dims.get('governance', 0),
                dims.get('monitoring_control', 0),
                dims.get('technology', 0),
                dims.get('organization', 0)
            ]
            values += values[:1]
            color = colors_list[i % len(colors_list)]
            values_list = [dims.get('governance', 0), dims.get('monitoring_control', 0), dims.get('technology', 0), dims.get('organization', 0)]
            n = len(values_list)
            avg_radius = sum(values_list) / n
            area = (n * (avg_radius ** 2) * np.sin(2 * np.pi / n)) / 2
            label = f"{proc.get('process', '')} ({area:.2f})"
            ax.plot(angles, values, 'o-', linewidth=2, color=color, label=label, markersize=4)
            ax.fill(angles, values, alpha=0.1, color=color)
        
        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(dimensions, size=11, weight='bold')
        ax.set_ylim(0, 5)
        ax.set_yticks([1, 2, 3, 4, 5])
        ax.grid(True, alpha=0.3)
        ax.legend(loc='upper right', bbox_to_anchor=(1.3, 1.1), fontsize=8)
        ax.set_theta_offset(np.pi/2)  # Governance in alto
        ax.set_aspect('equal')
        
        img_buffer = io.BytesIO()
        plt.savefig(img_buffer, format='png', dpi=100, bbox_inches='tight')
        plt.close()
        img_buffer.seek(0)
        
        from reportlab.lib.utils import ImageReader
        img = ImageReader(img_buffer)
        c.drawImage(img, self.margin_left - 1*cm, y_pos - 16*cm, width=18*cm, height=15*cm, preserveAspectRatio=True)

    def _add_radar_domains_vs_processes(self, c: canvas.Canvas, stats_data: Dict):
        """Radar con 7 assi (Processi) e 4 linee (Domini) - MKTG in alto"""
        y_pos = self.page_height - self.margin_top - 1*cm
        c.setFont('Helvetica-Bold', 16)
        c.setFillColor(colors.HexColor('#2C3E50'))
        c.drawString(self.margin_left, y_pos, "Global Radar - Domini vs Processi")
        
        processes_radar = stats_data.get('processes_radar', [])
        if not processes_radar:
            return
        
        # Ordina per overall_score per avere MKTG in posizione corretta
        # Ma per il radar, l'ordine deve essere quello della pagina: MKTG in alto
        # Ordiniamo alfabeticamente o per come appare online
        process_order = ['MKTG', 'DESIGN & ENGINEERING', 'EXECUTION', 'QUALITY MANAGEMENT', 'CUSTOMER CARE', 'DIGITAL MKTG', 'ADMINISTRATION']
        
        # Riordina secondo l'ordine specificato
        ordered_processes = []
        for pname in process_order:
            for p in processes_radar:
                if p.get('process', '').upper() == pname.upper():
                    ordered_processes.append(p)
                    break
        
        # Aggiungi eventuali processi mancanti
        for p in processes_radar:
            if p not in ordered_processes:
                ordered_processes.append(p)
        
        if not ordered_processes:
            ordered_processes = processes_radar
        
        fig, ax = plt.subplots(figsize=(7, 7), subplot_kw=dict(projection='polar'))
        
        process_names = [p.get('process', '')[:20] for p in ordered_processes]
        num_procs = len(process_names)
        angles = np.linspace(0, 2 * np.pi, num_procs, endpoint=False).tolist()
        # Rotazione gestita con set_theta_offset
        angles_plot = angles + [angles[0]]
        
        # 4 linee per i 4 domini
        domain_data = {
            'Governance': {'color': '#3B82F6', 'values': []},
            'Monitoring & Control': {'color': '#10B981', 'values': []},
            'Technology': {'color': '#F59E0B', 'values': []},
            'Organization': {'color': '#EF4444', 'values': []}
        }
        
        for proc in ordered_processes:
            dims = proc.get('dimensions', {})
            domain_data['Governance']['values'].append(dims.get('governance', 0))
            domain_data['Monitoring & Control']['values'].append(dims.get('monitoring_control', 0))
            domain_data['Technology']['values'].append(dims.get('technology', 0))
            domain_data['Organization']['values'].append(dims.get('organization', 0))
        
        for domain_name, data in domain_data.items():
            values = data['values'] + [data['values'][0]]
            total = sum(data['values'])
            ax.plot(angles_plot, values, 'o-', linewidth=2, color=data['color'], 
                   label=f"{domain_name} ({total:.2f})", markersize=4)
            ax.fill(angles_plot, values, alpha=0.1, color=data['color'])
        
        ax.set_xticks(angles)
        ax.set_xticklabels(process_names, size=8, weight='bold')
        ax.set_ylim(0, 5)
        ax.set_yticks([1, 2, 3, 4, 5])
        ax.grid(True, alpha=0.3)
        ax.legend(loc='upper right', bbox_to_anchor=(1.35, 1.1), fontsize=8)
        ax.set_theta_offset(np.pi/2)  # MKTG in alto
        ax.set_aspect('equal')
        
        img_buffer = io.BytesIO()
        plt.savefig(img_buffer, format='png', dpi=100, bbox_inches='tight')
        plt.close()
        img_buffer.seek(0)
        
        from reportlab.lib.utils import ImageReader
        img = ImageReader(img_buffer)
        c.drawImage(img, self.margin_left - 1*cm, y_pos - 16*cm, width=18*cm, height=15*cm, preserveAspectRatio=True)

    def _add_category_radars(self, c: canvas.Canvas, stats_data: Dict):
        """4 radar (uno per categoria) con 7 assi (processi)"""
        y_pos = self.page_height - self.margin_top - 1*cm
        c.setFont('Helvetica-Bold', 16)
        c.setFillColor(colors.HexColor('#2C3E50'))
        c.drawString(self.margin_left, y_pos, "Radar per Categoria")
        
        processes_radar = stats_data.get('processes_radar', [])
        if not processes_radar:
            return
        
        processes_radar = sorted(processes_radar, key=lambda x: x.get('overall_score', 0), reverse=True)
        
        categories = [
            ('Governance', 'governance'),
            ('Monitoring & Control', 'monitoring_control'),
            ('Technology', 'technology'),
            ('Organization', 'organization')
        ]
        
        positions = [
            (self.margin_left, self.page_height - 5.5*cm),
            (self.margin_left + 9*cm, self.page_height - 5.5*cm),
            (self.margin_left, self.page_height - 14.5*cm),
            (self.margin_left + 9*cm, self.page_height - 14.5*cm)
        ]
        
        for idx, (cat_name, cat_key) in enumerate(categories):
            x_pos, y_pos = positions[idx]
            
            fig, ax = plt.subplots(figsize=(3.2, 3.2), subplot_kw=dict(projection='polar'))
            
            process_names = [p.get('process', '')[:12] for p in processes_radar]
            values = [p.get('dimensions', {}).get(cat_key, 0) for p in processes_radar]
            
            num_procs = len(process_names)
            angles = np.linspace(0, 2 * np.pi, num_procs, endpoint=False).tolist()
            # Rotazione gestita con set_theta_offset
            values_plot = values + [values[0]]
            angles_plot = angles + [angles[0]]
            
            ax.plot(angles_plot, values_plot, 'o-', linewidth=2, color='#3DBFBF', markersize=4)
            ax.fill(angles_plot, values_plot, alpha=0.3, color='#3DBFBF')
            
            ax.set_xticks(angles)
            ax.set_xticklabels(process_names, size=5)
            ax.set_ylim(0, 5)
            ax.set_yticks([1, 2, 3, 4, 5])
            ax.set_yticklabels(['1', '2', '3', '4', '5'], size=5)
            ax.grid(True, alpha=0.3)
            ax.set_theta_offset(np.pi/2)  # Primo processo in alto
            ax.set_aspect('equal')
            plt.title(cat_name, size=9, weight='bold', y=1.08)
            
            img_buffer = io.BytesIO()
            plt.savefig(img_buffer, format='png', dpi=90, bbox_inches='tight')
            plt.close()
            img_buffer.seek(0)
            
            from reportlab.lib.utils import ImageReader
            img = ImageReader(img_buffer)
            c.drawImage(img, x_pos, y_pos - 8*cm, width=8*cm, height=8*cm, preserveAspectRatio=True)

    def _add_process_radars(self, c: canvas.Canvas, stats_data: Dict):
        """7 radar (uno per processo) con 4 assi (domini)"""
        y_pos = self.page_height - self.margin_top - 1*cm
        c.setFont('Helvetica-Bold', 16)
        c.setFillColor(colors.HexColor('#2C3E50'))
        c.drawString(self.margin_left, y_pos, "Radar per Processo")
        
        processes_radar = stats_data.get('processes_radar', [])
        if not processes_radar:
            return
        
        processes_radar = sorted(processes_radar, key=lambda x: x.get('overall_score', 0), reverse=True)
        
        radar_w = 5*cm
        radar_h = 5*cm
        cols = 3
        x_start = self.margin_left
        y_start = self.page_height - self.margin_top - 3*cm
        
        for idx, proc in enumerate(processes_radar[:9]):
            col = idx % cols
            row = idx // cols
            x_pos = x_start + col * (radar_w + 0.8*cm)
            y_pos = y_start - row * (radar_h + 1.8*cm)
            
            dims = proc.get('dimensions', {})
            process_name = proc.get('process', '')[:18]
            overall = proc.get('overall_score', 0)
            
            fig, ax = plt.subplots(figsize=(2.2, 2.2), subplot_kw=dict(projection='polar'))
            
            dimensions = ['Gov', 'M&C', 'Tech', 'Org']
            values = [
                dims.get('governance', 0),
                dims.get('monitoring_control', 0),
                dims.get('technology', 0),
                dims.get('organization', 0)
            ]
            
            num_dims = len(dimensions)
            angles = np.linspace(0, 2 * np.pi, num_dims, endpoint=False).tolist()
            # Rotazione gestita con set_theta_offset
            values += values[:1]
            angles += angles[:1]
            
            ax.plot(angles, values, 'o-', linewidth=1.5, color='#3B82F6', markersize=3)
            ax.fill(angles, values, alpha=0.3, color='#3B82F6')
            
            ax.set_xticks(angles[:-1])
            ax.set_xticklabels(dimensions, size=6)
            ax.set_ylim(0, 5)
            ax.set_yticks([1, 2, 3, 4, 5])
            ax.set_yticklabels(['', '', '', '', ''], size=5)
            ax.grid(True, alpha=0.3)
            ax.set_theta_offset(np.pi/2)  # Governance in alto
            ax.set_aspect('equal')
            plt.title(f'{process_name}\n({overall:.2f})', size=7, weight='bold', y=1.08)
            
            img_buffer = io.BytesIO()
            plt.savefig(img_buffer, format='png', dpi=80, bbox_inches='tight')
            plt.close()
            img_buffer.seek(0)
            
            from reportlab.lib.utils import ImageReader
            img = ImageReader(img_buffer)
            c.drawImage(img, x_pos, y_pos - radar_h, width=radar_w, height=radar_h, preserveAspectRatio=True)

    def _add_strengths_weaknesses(self, c: canvas.Canvas, stats_data: Dict, results_data: List[Dict]):
        """Tabella Strengths & Weaknesses - replica esatta del frontend"""
        from reportlab.lib.units import cm
        from reportlab.lib import colors
        
        y_pos = self.page_height - self.margin_top - 3*cm
        c.setFont('Helvetica-Bold', 14)
        c.setFillColor(colors.HexColor('#2C3E50'))
        c.drawString(self.margin_left, y_pos, "STRENGTHS & WEAKNESSES BY PROCESS")
        y_pos -= 1.2*cm
        
        processes_radar = stats_data.get('processes_radar', [])
        if not processes_radar:
            return
        
        # Ordine fisso
        process_order = ['MKTG', 'DESIGN & ENGINEERING', 'EXECUTION', 'QUALITY MANAGEMENT', 
                        'CUSTOMER CARE', 'DIGITAL MKTG', 'ADMINISTRATION']
        ordered_processes = []
        for pname in process_order:
            for p in processes_radar:
                if p.get('process', '').upper() == pname.upper():
                    ordered_processes.append(p)
                    break
        processes_radar = ordered_processes if ordered_processes else processes_radar
        
        # Organizza results_data per calcolare strengths/weaknesses per attività
        # Struttura: process -> activity -> list of scores
        activity_scores = {}
        activity_notes = {}
        for r in results_data:
            proc = r.get('process', '')
            act = r.get('activity', '')
            score = r.get('score', 0)
            note = r.get('note', '')
            cat = r.get('category', '')
            
            if proc not in activity_scores:
                activity_scores[proc] = {}
                activity_notes[proc] = {}
            if act not in activity_scores[proc]:
                activity_scores[proc][act] = {'scores': [], 'by_cat': {}}
            
            if score is not None and not r.get('is_not_applicable', False):
                activity_scores[proc][act]['scores'].append(score)
                if cat not in activity_scores[proc][act]['by_cat']:
                    activity_scores[proc][act]['by_cat'][cat] = []
                activity_scores[proc][act]['by_cat'][cat].append(score)
            
            if note and act not in activity_notes[proc]:
                activity_notes[proc][act] = note
        
        # Header
        c.setFont('Helvetica-Bold', 7)
        c.setFillColor(colors.HexColor('#3DBFBF'))
        c.rect(self.margin_left, y_pos - 0.5*cm, self.content_width, 0.6*cm, fill=1)
        c.setFillColor(colors.white)
        
        col_widths = [2.8*cm, 3.2*cm, 4.8*cm, 4.8*cm, 1.2*cm]
        col_x = [self.margin_left + 0.1*cm]
        for w in col_widths[:-1]:
            col_x.append(col_x[-1] + w)
        
        headers = ['Process Area', 'Dimension', 'Strengths (≥ 3.0)', 'Weaknesses (< 2.0)', 'RATING']
        for i, h in enumerate(headers):
            c.drawString(col_x[i], y_pos - 0.3*cm, h)
        y_pos -= 0.9*cm
        
        dim_names = ['Governance', 'Monitoring & Control', 'Technology', 'Organization']
        
        for proc_data in processes_radar:
            proc_name = proc_data.get('process', '')
            dims = proc_data.get('dimensions', {})
            overall = proc_data.get('overall_score', 0)
            
            # Calcola strengths e weaknesses per categoria
            strengths_by_cat = {d: [] for d in dim_names}
            weaknesses_by_cat = {d: [] for d in dim_names}
            all_activities = []
            
            if proc_name in activity_scores:
                for act_name, act_data in activity_scores[proc_name].items():
                    if act_data['scores']:
                        avg = sum(act_data['scores']) / len(act_data['scores'])
                        note = activity_notes.get(proc_name, {}).get(act_name, '')
                        all_activities.append({'name': act_name, 'avg': avg, 'note': note})
                        
                        # Assegna a strengths o weaknesses in base al punteggio SPECIFICO per quella dimensione
                        for cat in dim_names:
                            if cat in act_data['by_cat'] and act_data['by_cat'][cat]:
                                cat_score = sum(act_data['by_cat'][cat]) / len(act_data['by_cat'][cat])
                                if cat_score >= 3.0:
                                    strengths_by_cat[cat].append((act_name, cat_score))
                                elif cat_score < 2.0:
                                    weaknesses_by_cat[cat].append((act_name, cat_score))
            
            # Calcola altezza necessaria
            num_activities = len(all_activities)
            dim_section_height = 4 * 1.2*cm  # 4 dimensioni
            note_section_height = num_activities * 0.45*cm + 0.5*cm
            total_height = dim_section_height + note_section_height
            
            if y_pos - total_height < 2*cm:
                c.showPage()
                self._draw_report_page(c)
                y_pos = self.page_height - self.margin_top - 1*cm
            
            # Box processo
            c.setStrokeColor(colors.HexColor('#DEE2E6'))
            c.setLineWidth(0.5)
            c.rect(self.margin_left, y_pos - total_height, self.content_width, total_height, stroke=1, fill=0)
            
            # Separatori verticali tra colonne
            for col_sep in col_x[1:]:
                c.line(col_sep - 0.1*cm, y_pos, col_sep - 0.1*cm, y_pos - total_height)
            
            # Nome processo (centrato verticalmente, con a capo se lungo)
            c.setFont('Helvetica-Bold', 8)
            c.setFillColor(colors.HexColor('#333333'))
            proc_center_y = y_pos - total_height/2
            # Gestisci nomi lunghi andando a capo
            if len(proc_name) > 15:
                words = proc_name.split()
                if len(words) >= 2:
                    line1 = ' '.join(words[:len(words)//2])
                    line2 = ' '.join(words[len(words)//2:])
                    c.drawString(col_x[0], proc_center_y + 0.2*cm, line1[:15])
                    c.drawString(col_x[0], proc_center_y - 0.2*cm, line2[:15])
                else:
                    c.drawString(col_x[0], proc_center_y, proc_name[:15])
            else:
                c.drawString(col_x[0], proc_center_y, proc_name)
            
            # 4 Dimensioni
            dim_y = y_pos - 0.8*cm
            for cat in dim_names:
                cat_key = cat.lower().replace(' & ', '_').replace(' ', '_')
                if cat == 'Monitoring & Control':
                    cat_key = 'monitoring_control'
                val = dims.get(cat_key, 0)
                
                # Icona colorata
                if val >= 3.0:
                    c.setFillColor(colors.HexColor('#10B981'))
                elif val >= 2.0:
                    c.setFillColor(colors.HexColor('#9CA3AF'))
                else:
                    c.setFillColor(colors.HexColor('#EF4444'))
                c.circle(col_x[1] + 0.15*cm, dim_y + 0.1*cm, 0.15*cm, fill=1)
                
                # Nome e valore
                c.setFillColor(colors.HexColor('#333333'))
                c.setFont('Helvetica', 7)
                cat_short = cat.replace('Monitoring & Control', 'Monitoring &\nControl')
                c.drawString(col_x[1] + 0.4*cm, dim_y, f"{cat} ({val:.2f})")
                
                # Strengths (lista puntata, vai a capo se necessario)
                c.setFillColor(colors.HexColor('#059669'))
                c.setFont('Helvetica', 6)
                s_list = strengths_by_cat[cat][:3]
                if s_list:
                    s_y = dim_y
                    for s in s_list:
                        text = f"• {s[0]} ({s[1]:.2f})"
                        if len(text) > 35:
                            text = f"• {s[0][:25]}... ({s[1]:.2f})"
                        c.drawString(col_x[2], s_y, text)
                        s_y -= 0.3*cm
                else:
                    c.setFillColor(colors.HexColor('#9CA3AF'))
                    c.drawString(col_x[2], dim_y, "-")
                
                # Weaknesses
                c.setFillColor(colors.HexColor('#DC2626'))
                w_list = weaknesses_by_cat[cat][:3]
                if w_list:
                    w_y = dim_y
                    for w in w_list:
                        text = f"• {w[0]} ({w[1]:.2f})"
                        if len(text) > 35:
                            text = f"• {w[0][:25]}... ({w[1]:.2f})"
                        c.drawString(col_x[3], w_y, text)
                        w_y -= 0.3*cm
                else:
                    c.setFillColor(colors.HexColor('#9CA3AF'))
                    c.drawString(col_x[3], dim_y, "-")
                
                dim_y -= 1.2*cm
            
            # Sezione Note
            c.setFont('Helvetica-Bold', 7)
            c.setFillColor(colors.HexColor('#666666'))
            c.drawString(col_x[1], dim_y + 0.3*cm, "Note")
            
            note_y = dim_y
            c.setFont('Helvetica', 5.5)
            for act in all_activities:
                avg = act['avg']
                # Icona colorata per punteggio
                if avg >= 3.0:
                    c.setFillColor(colors.HexColor('#10B981'))
                elif avg >= 2.0:
                    c.setFillColor(colors.HexColor('#9CA3AF'))
                elif avg < 1.0:
                    c.setFillColor(colors.HexColor('#EF4444'))
                else:
                    c.setFillColor(colors.HexColor('#F59E0B'))
                c.circle(col_x[2] - 0.2*cm, note_y + 0.08*cm, 0.08*cm, fill=1)
                
                # Testo attività + nota
                c.setFillColor(colors.HexColor('#333333'))
                act_text = f"{act['name']} ({avg:.2f})"
                note_text = act.get('note', '')
                
                # Combina e tronca se troppo lungo
                full_text = f"{act_text}  {note_text}"
                if len(full_text) > 100:
                    full_text = full_text[:97] + "..."
                c.drawString(col_x[2], note_y, full_text)
                note_y -= 0.45*cm
            
            # RATING
            c.setFont('Helvetica-Bold', 11)
            if overall >= 3.0:
                c.setFillColor(colors.HexColor('#10B981'))
            elif overall >= 2.0:
                c.setFillColor(colors.HexColor('#F59E0B'))
            else:
                c.setFillColor(colors.HexColor('#EF4444'))
            c.drawString(col_x[4], proc_center_y, f"{overall:.2f}")
            
            y_pos -= total_height + 0.5*cm

    def _add_ai_pages(self, c: canvas.Canvas, ai_conclusions: str):
        """Pagine conclusioni AI"""
        self._draw_ai_page(c)
        y_pos = self.page_height - self.margin_top - 3*cm  # Più in basso per evitare sovrapposizioni
        
        c.setFont('Helvetica-Bold', 16)
        c.setFillColor(colors.HexColor('#2C3E50'))
        c.drawString(self.margin_left, y_pos, "CONCLUSIONI E RACCOMANDAZIONI AI")
        y_pos -= 1*cm
        
        lines = ai_conclusions.split('\n')
        line_height = 10
        
        for line in lines:
            if y_pos < self.margin_bottom + 2*cm:
                c.showPage()
                self._draw_ai_page(c)
                y_pos = self.page_height - self.margin_top - 3*cm
            
            line = line.strip()
            if not line:
                y_pos -= line_height * 0.5
                continue
            
            if line.startswith('###'):
                c.setFont('Helvetica-Bold', 11)
                c.setFillColor(colors.HexColor('#2C3E50'))
                line = line.replace('###', '').strip()
                y_pos -= 0.2*cm
            elif line.startswith('##'):
                c.setFont('Helvetica-Bold', 12)
                c.setFillColor(colors.HexColor('#2C3E50'))
                line = line.replace('##', '').strip()
                y_pos -= 0.3*cm
            elif line.startswith('#'):
                c.setFont('Helvetica-Bold', 13)
                c.setFillColor(colors.HexColor('#2C3E50'))
                line = line.replace('#', '').strip()
                y_pos -= 0.4*cm
            elif line.startswith('-'):
                c.setFont('Helvetica', 8)
                c.setFillColor(colors.HexColor('#333333'))
                line = '• ' + line[1:].strip()
            else:
                c.setFont('Helvetica', 8)
                c.setFillColor(colors.HexColor('#333333'))
            
            words = line.split()
            current_line = ""
            for word in words:
                test_line = current_line + " " + word if current_line else word
                if c.stringWidth(test_line, c._fontname, c._fontsize) < self.content_width:
                    current_line = test_line
                else:
                    if current_line:
                        c.drawString(self.margin_left, y_pos, current_line)
                        y_pos -= line_height
                        if y_pos < self.margin_bottom + 2*cm:
                            c.showPage()
                            self._draw_ai_page(c)
                            y_pos = self.page_height - self.margin_top - 3*cm
                    current_line = word
            if current_line:
                c.drawString(self.margin_left, y_pos, current_line)
                y_pos -= line_height
        
        c.showPage()

    def _draw_ai_page(self, c: canvas.Canvas):
        c.drawImage(self.ai_template, 0, 0, width=self.page_width, height=self.page_height, preserveAspectRatio=True, mask='auto')
